We understand it's a lot of ground to cover and would like to request a
session of 90 minutes to demonstrate and explain the concepts.  Even then
we will have to be firm on timings.  With a pair of presenters we will be
able to talk, while fiddling with the environment.  Our plan is to make
everything that we can be self-contained, so any failings are our fault.
We will attempt to record the demonstrations so we can have a fall-back
plan.  A particular challenge that we will face will be to make video
readable on the big screen. It might be easier to take many screenshots,
so we can highlight relevant text, and display it at a larger font size.

Ideally we'd be able to have an iPad/laptop for the slides and a laptop
for the demonstrations, but I'm not sure how feasible that will be until
we can talk to the A/V staff at the conference.

The session will run as follows:

00:00 - 00:10 Introduction, latecomers and schedule.

It'll be hard to summarize all the ground that we have to cover, so we'll
try and push that into each session.  What is imporant is to demonstrate
(however briefly) the application that is our vehicle for the talk.
We'll make the examples related to deploying this application - a
simple Ruby application (simple because it's a demo and we don't want
to provoke Murphy, and Ruby because it can have annoying dependencies -
which chimes with our message that you're not done until it's deployed
in production).  We mention many technology options below, but will
only demonstrate one - that's subject to change at the moment because
we have no vendor alliances (we might like some more than others, and
we both run consulting companies, but apart from that ...)

00:11 - 00:20 Installation of the operating system.

We might as well diverge at the start.  The production operating system
install generally comes later in the project lifecycle, but we're going
to front-load it because a) it's much easier these days and b) we want
system integration from the start.  We'll be using the Vagrant tool to
build virtual machines, with the VeeWee wrapper that makes bootstrapper
easier. [Pat, what's the timings on the install?]

00:21 - 00:30 Configuration Management.

We plan to to use the Chef tool to make a basic 'recipe' ( Chef's term
for a configuration to be applied to our brand new VM;  we'll also have
one we prepared earlier; you do learn things from daytime TV!).  We'll
check that into the Git version control system, so we can track changes.
We've already turned the tables on traditional systems administration at
this point; We could trash Patrick's macbook at this stage and rebuild
our VM from source, as long as we had the git sources.

00:31 - 00:45 Behavioral Monitoring

We're fond of the Cucumber BDD tool.  It can also be used for testing
infrastructure, so we'll knock up some quick Cucumber scenarios that
pertain to our infrastructure, to make sure that the machine is working
correctly.  Then we'll show how those tests can be driven from the popular
open source monitoring tool, Nagios (via the cucumber-nagios plugin).

00:46 - 00:60 Application Development

We'll make a very simple Ruby on Rails application, and version control
it in Git. We'll add some trivial unit tests and a cucumber feature.
We will add the tests to a Hudson Continuous Integration server, so our
(hypethetical ) colleagues have the assurance that we're ready to release
our code at any time.  Later we'll add use the Cucumber feature to prove
that the the code continues to work, after it's deployed.

[ do you know what would freaking rock?  getting members of the audience
to run nagios and hudson from VM's]


[ will we run hudson against the VM that we made? ]

0:61 - 00:70 Runtime!

We'll deploy the application to the virtual machine that we prepared
earlier, our using Vlad the Deployer.  We'll update Nagios to start
running the Cucumber tests that we made when we wrote the application,
so the operations department can have assurance that the code is doing
what it should.

00:71 - 00:80 Runtime in the cloud

We'll demonstrate that with some tiny configuration changes, we can deploy
the same operating system configurations and the same application on a
brand-new cloud infrastructure.  You want DR?  We have DR!

00:81 - 00:90 Wrap-up

Contingency, recap and questions.





OLD ====

00:05 - 00:15: cloud and virtualization abstraction: libvirt, fog,
jclouds.  We'll discuss the incredible convenience of deploying nodes
via an API, and reflect on how horrid it used to be, before deploying
a VM from some code.

00:15-00:25: configuration management tools: chef, puppet.  We'll use
these tools to put some useful components (the Ruby interpreter,
libraries, and tools) onto the VM, so we can deploy the application later.

00:25-00:35: how to version control these recipes and other dependencies
like packages using git or other tools.  We'll discuss the fundamental
importance of version control for developers and infrastructure people
alike, and demonstrate that we have version controlled the code.

00:35-00:45: setup a private 'infrastructure code' development
environment - by this we mean some of the tooling that we use to manage
our infrastructure-as-code.  We'll try and equate these with typical
developer tools.

00:45-00:55- how write tests for these code concepts: puppet-cucumber,
cucumber-nagios.  The infrastructure community has evolved its own tools
for testing, and we discuss and demonstrate these.

00:55-00:65 integration options in your CI tool: hudson, cruisecontrol -
Once you have version control, it unlocks many possibilities, both good
and bad. We'll discuss the problems of integration pain and demonstrate
that a CI server can work for both development code and infrastructure
code.

00:65-00:75 deployment of the artifacts, virtual machine: or virtual
environment - we'll demonstrate that the virtual machine can be torn down
and rebuild with impunity.  It's behaviours like this that are driving
the infrastructure revolution.  No longer do you need to obsessively watch
backups of your entire system; you can focus on the data because you can
demonstrate your ability to rebuild.  00:75-00:80 application deployment
through one configuration management tool: war, gems - we'll deploy the
application and its dependencies with a single command. We're doing this
quickly as it shouldn't be earth shattering for most participants.

00:80-00:90 contingency and questions.

The ultimate goal is to demonstrate change both the definition of a
system and a line of code and have it build and update the live system
automatically.  We'll be making this point to the audience throughout
the talk.

The explanation will be given as each tool is demonstrated.

_References :_

-
[http://www.agileweboperations.com/system-configurations-code-revisions-continuous-integration-ftw](http://www.agileweboperations.com/system-configurations-code-revisions-continuous-integration-ftw)
-
[http://www.slideshare.net/jedi4ever/continuous-integration-for-the-world-keynote-final](http://www.slideshare.net/jedi4ever/continuous-integration-for-the-world-keynote-final)
-
[http://www.slideshare.net/jedi4ever/devops-the-war-is-over-if-you-want-it](http://www.slideshare.net/jedi4ever/devops-the-war-is-over-if-you-want-it)
from slide 54

